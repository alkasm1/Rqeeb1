<!DOCTYPE html>
<html>
<head>
  <title>analyzer-7</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f0f0f0; }
    canvas { border: 1px solid #ccc; margin-top: 10px; }
    #controls { margin: 20px; }
    button { padding: 10px 20px; margin: 5px; }
  </style>
</head>
<body>
  <h1>analyzer-7</h1>
  <div id="controls">
    <input type="file" id="upload" accept="image/*">
    <button onclick="toggleSmartMode()">وضع التحليل الذكي: <span id="modeLabel">إيقاف</span></button>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    let smartMode = false;

    function toggleSmartMode() {
      smartMode = !smartMode;
      document.getElementById('modeLabel').textContent = smartMode ? 'تشغيل' : 'إيقاف';
      if (imageData) processImage(imageData);
    }

    let imageData = null;

    document.getElementById('upload').addEventListener('change', function(e) {
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          const canvas = document.getElementById('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          processImage(imageData);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    });

    function processImage(data) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      ctx.putImageData(data, 0, 0);

      // تحويل الصورة إلى أبيض وأسود
      const gray = new Uint8ClampedArray(data.data.length / 4);
      for (let i = 0; i < data.data.length; i += 4) {
        gray[i / 4] = 0.299 * data.data[i] + 0.587 * data.data[i + 1] + 0.114 * data.data[i + 2];
      }

      // اكتشاف الحواف (Sobel بسيط)
      const width = canvas.width;
      const height = canvas.height;
      const edges = new Uint8ClampedArray(gray.length);
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const i = y * width + x;
          const gx = gray[i - 1] - gray[i + 1];
          const gy = gray[i - width] - gray[i + width];
          edges[i] = Math.sqrt(gx * gx + gy * gy);
        }
      }

      // استخراج المناطق ذات الحواف العالية
      const threshold = 100;
      const regions = [];
      for (let y = 0; y < height; y += 10) {
        for (let x = 0; x < width; x += 10) {
          let sum = 0;
          for (let dy = 0; dy < 10; dy++) {
            for (let dx = 0; dx < 10; dx++) {
              const i = (y + dy) * width + (x + dx);
              sum += edges[i] || 0;
            }
          }
          if (sum > threshold * 100) {
            regions.push({ x, y, w: 100, h: 100 });
          }
        }
      }

      // دمج المناطق المتجاورة (مبسط)
      const merged = [];
      regions.forEach(r => {
        let found = false;
        for (let m of merged) {
          if (Math.abs(r.x - m.x) < 150 && Math.abs(r.y - m.y) < 150) {
            m.x = Math.min(m.x, r.x);
            m.y = Math.min(m.y, r.y);
            m.w = Math.max(m.w, r.x + r.w - m.x);
            m.h = Math.max(m.h, r.y + r.h - m.y);
            found = true;
            break;
          }
        }
        if (!found) merged.push({ ...r });
      });

      // اختيار مستندين
      let selected = [];
      if (smartMode) {
        // الوضع الذكي: اختيار الزوج الأكثر تشابهًا هندسيًا
        let bestPair = null;
        let bestScore = Infinity;
        for (let i = 0; i < merged.length; i++) {
          for (let j = i + 1; j < merged.length; j++) {
            const a = merged[i], b = merged[j];
            const ar = a.w / a.h, br = b.w / b.h;
            const ratioDiff = Math.abs(ar - br);
            const sizeDiff = Math.abs((a.w * a.h) - (b.w * b.h)) / Math.max(a.w * a.h, b.w * b.h);
            const score = ratioDiff + sizeDiff;
            if (score < bestScore) {
              bestScore = score;
              bestPair = [a, b];
            }
          }
        }
        if (bestPair) selected = bestPair;
      } else {
        // الوضع العادي: اختيار أول مستندين كبيرين
        selected = merged.sort((a, b) => (b.w * b.h) - (a.w * a.h)).slice(0, 2);
      }

      // رسم المستندين المختارين
      ctx.putImageData(data, 0, 0);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      selected.forEach(r => {
        ctx.strokeRect(r.x, r.y, r.w, r.h);
      });
    }
  </script>
</body>
</html>
