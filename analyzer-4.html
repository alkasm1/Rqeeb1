<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <title>Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¨ØµØ±ÙŠ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ù…Ø³ØªÙ†Ø¯ÙŠÙ†</title>
  <style>
    body {
      background: #0b0b0b;
      color: #ff8800;
      font-family: 'Cairo', sans-serif;
      text-align: center;
      padding: 1rem;
    }
    video {
      width: 100%;
      max-width: 500px;
      border: 2px solid #ff8800;
      margin-bottom: 10px;
    }
    .container {
      position: relative;
      width: 100%;
      max-width: 500px;
      margin: auto;
    }
    button {
      margin: 1rem;
      padding: 0.8rem;
      font-size: 1rem;
      border-radius: 8px;
      background: #ff8800;
      color: white;
      border: none;
      cursor: pointer;
    }
    canvas { display: none; }
    #results, #status {
      margin-top: 1rem;
      font-size: 1rem;
      color: #ccc;
    }
    #confirmBtn { display: none; }
  </style>
</head>
<body>
  <h2>ğŸ§  Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¨ØµØ±ÙŠ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ù…Ø³ØªÙ†Ø¯ÙŠÙ†</h2>
  <div class="container">
    <video id="video" autoplay playsinline></video>
  </div>
  <button onclick="analyze()">ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´ÙƒÙ„ ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰</button>
  <button id="confirmBtn" onclick="confirmMatch()">âœ… ØªØ­Ù‚Ù‚ ÙØ¹Ù„ÙŠ</button>
  <canvas id="canvas"></canvas>
  <div id="status"></div>
  <div id="results"></div>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
  .then(stream => video.srcObject = stream)
  .catch(err => alert("ğŸš« ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§"));

function confirmMatch() {
  alert("ğŸ›¡ï¸ ØªØ­Ù‚Ù‚ ÙØ¹Ù„ÙŠ ØªÙ… Ø¨Ù†Ø¬Ø§Ø­. Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ù…ØªØ·Ø§Ø¨Ù‚Ø© Ø¨Ø¯Ø±Ø¬Ø© Ø¹Ø§Ù„ÙŠØ©.");
}

function analyze() {
  if (video.readyState < 2) return alert("ğŸ“· Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ØºÙŠØ± Ø¬Ø§Ù‡Ø²Ø© Ø¨Ø¹Ø¯");
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const { leftShape, rightShape } = detectMatchingShapes(imageData);

  if (!leftShape || !rightShape) {
    document.getElementById("results").innerHTML = "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø´ÙƒÙ„ÙŠÙ† Ù‡Ù†Ø¯Ø³ÙŠÙŠÙ† Ù…ØªØ´Ø§Ø¨Ù‡ÙŠÙ†";
    return;
  }

  ctx.strokeStyle = "#0f0";
  ctx.lineWidth = 2;
  ctx.strokeRect(leftShape.x, leftShape.y, leftShape.w, leftShape.h);

  ctx.strokeStyle = "#f00";
  ctx.lineWidth = 2;
  ctx.strokeRect(rightShape.x, rightShape.y, rightShape.w, rightShape.h);

  document.getElementById("status").innerText = "âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø´ÙƒÙ„ÙŠÙ† Ù‡Ù†Ø¯Ø³ÙŠÙŠÙ† ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ù„Ù„ØªØ­Ù„ÙŠÙ„";

  const leftData = ctx.getImageData(leftShape.x, leftShape.y, leftShape.w, leftShape.h);
  const rightData = ctx.getImageData(rightShape.x, rightShape.y, rightShape.w, rightShape.h);

  const shapeScore = estimateShapeMatch(leftData, rightData);
  if (shapeScore < 50) {
    document.getElementById("confirmBtn").style.display = "none";
    document.getElementById("results").innerHTML =
      `ğŸ“ Ù†Ø³Ø¨Ø© ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ: ${shapeScore.toFixed(1)}% âŒ Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ (50%)`;
    return;
  }

  const colorScore = compareHSVSimilarity(leftData.data, rightData.data);
  const texture1 = analyzeTexture(leftData);
  const texture2 = analyzeTexture(rightData);
  const diffAvg = Math.abs(texture1.avg - texture2.avg);
  const diffDev = Math.abs(texture1.dev - texture2.dev);
  const textureScore = 100 - Math.min((diffAvg + diffDev) / 2, 100);
  const decision = getScientificDecision(colorScore, textureScore);

  let resultText = `
    ğŸ“ Ù†Ø³Ø¨Ø© Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ (ØªÙ… ØªØ¬Ø§ÙˆØ²Ù‡Ø§): ${shapeScore.toFixed(1)}% âœ…<br>
    ğŸ¨ Ù†Ø³Ø¨Ø© ØªØ´Ø§Ø¨Ù‡ Ø§Ù„Ù„ÙˆÙ† (HSV): ${colorScore.toFixed(1)}%<br>
    ğŸ§µ Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø³ÙŠØ¬: ${textureScore.toFixed(1)}%<br><br>
    ğŸ§  Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ (Ø¯ÙˆÙ† Ø§Ù„Ø´ÙƒÙ„): ${decision.finalScore}%<br>
    ${decision.decision}
  `;
  document.getElementById("results").innerHTML = resultText;
  document.getElementById("confirmBtn").style.display = "inline-block";
}

function detectMatchingShapes(imageData) {
  const { width, height, data } = imageData;
  const gray = new Uint8ClampedArray(width * height);
  for (let i = 0, j = 0; i < data.length; i += 4, j++) {
    gray[j] = (data[i] + data[i+1] + data[i+2]) / 3;
  }

  const sobel = new Uint8ClampedArray(gray.length);
  const gx = [-1,0,1,-2,0,2,-1,0,1];
  const gy = [-1,-2,-1,0,0,0,1,2,1];

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      let px = 0, py = 0;
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const idx = (y + ky) * width + (x + kx);
          const weightX = gx[(ky + 1) * 3 + (kx + 1)];
          const weightY = gy[(ky + 1) * 3 + (kx + 1)];
          px += gray[idx] * weightX;
          py += gray[idx] * weightY;
        }
      }
      const mag = Math.sqrt(px * px + py * py);
      sobel[y * width + x] = mag > 100 ? 255 : 0;
    }
  }

  function findBoxes(startX, endX) {
    const shapes = [];
    for (let y = 0; y < height - 30; y += 10) {
      for (let x = startX; x < endX - 30; x += 10) {
        let count = 0;
        for (let dy = 0; dy < 30; dy++) {
          for (let dx = 0; dx < 30; dx++) {
            const idx = (y + dy) * width + (x + dx);
            if (sobel[idx] === 255) count++;
          }
        }
        if (count > 300) shapes.push({ x, y, w: 30, h: 30, score: count });
      }
    }
    return shapes;
  }

  const mid = Math.floor(width / 2);
  const leftShapes = findBoxes(0, mid);
  const rightShapes = findBoxes(mid, width);

  let bestPair = null;
  let minDiff = Infinity;
  for (let l of leftShapes) {
    for (let r of rightShapes) {
      const diff = Math.abs(l.score - r.score);
      if (diff < minDiff) {
        minDiff = diff;
        bestPair = { leftShape: l, rightShape: r };
      }
    }
  }

  return bestPair || { leftShape: null, rightShape: null };
}

function compareHSVSimilarity(data1, data2) {
  function rgbToHsv(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    const d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) h = 0;
    else {
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h =[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/AlexUlianets/WH_project/tree/8c4c3575f69f17ab853e50604568cac5736dcfe4/src%2Fapp%2Fservices%2Fhsl.color.service.ts?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "1")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/SEUNAKINTOLA/Mini-unsplash-clone/tree/f49b3e19b20c63678f336cb03775a08b5324b7da/Mini%20unsplash%20clone%2FClientApp%2Fsrc%2Fapp%2Fshared%2Fcommon%2Futil.ts?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "2")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/riophae/what-color-is-it/tree/7e8a17f73bb33af3b10bc3b2b95a2f30b5d6b42b/colz.class.min.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "3")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/HelKyle/antd-multi-cascader/tree/f7217a51ae8b86f3f7838e0d726bc90acd6394f2/docs%2Fvendors~main.f9a871f0.iframe.bundle.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "4")
